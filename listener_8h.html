<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libevent: event2/listener.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libevent
   &#160;<span id="projectnumber">2.2.1</span>
   </div>
   <div id="projectbrief">Event notification library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_db160b4728e6067cf5f9cc14ec42c79d.html">event2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">listener.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A callback that we invoke when a listener has a new connection.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;event2/visibility.h&gt;</code><br />
<code>#include &lt;<a class="el" href="event_8h_source.html">event2/event.h</a>&gt;</code><br />
</div>
<p><a href="listener_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afc396525343a6848149d6c0f7cd11ed5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#afc396525343a6848149d6c0f7cd11ed5">LEV_OPT_BIND_IPV4_AND_IPV6</a>&#160;&#160;&#160;(1u&lt;&lt;9)</td></tr>
<tr class="memdesc:afc396525343a6848149d6c0f7cd11ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that the listener wants to work only in both IPv4 and IPv6 socket.  <a href="listener_8h.html#afc396525343a6848149d6c0f7cd11ed5">More...</a><br /></td></tr>
<tr class="separator:afc396525343a6848149d6c0f7cd11ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a54f81b44cec176dffe72a1aa22d8e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a3a54f81b44cec176dffe72a1aa22d8e6">LEV_OPT_BIND_IPV6ONLY</a>&#160;&#160;&#160;(1u&lt;&lt;8)</td></tr>
<tr class="memdesc:a3a54f81b44cec176dffe72a1aa22d8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that the listener wants to work only in IPv6 socket.  <a href="listener_8h.html#a3a54f81b44cec176dffe72a1aa22d8e6">More...</a><br /></td></tr>
<tr class="separator:a3a54f81b44cec176dffe72a1aa22d8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f307bd279abe88586fb56672fcf6c8"><td class="memItemLeft" align="right" valign="top"><a id="af6f307bd279abe88586fb56672fcf6c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#af6f307bd279abe88586fb56672fcf6c8">LEV_OPT_CLOSE_ON_EXEC</a>&#160;&#160;&#160;(1u&lt;&lt;2)</td></tr>
<tr class="memdesc:af6f307bd279abe88586fb56672fcf6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that we should set the close-on-exec flag, if possible. <br /></td></tr>
<tr class="separator:af6f307bd279abe88586fb56672fcf6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2de09b129675a41696a89e5c58de53"><td class="memItemLeft" align="right" valign="top"><a id="a4b2de09b129675a41696a89e5c58de53"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a4b2de09b129675a41696a89e5c58de53">LEV_OPT_CLOSE_ON_FREE</a>&#160;&#160;&#160;(1u&lt;&lt;1)</td></tr>
<tr class="memdesc:a4b2de09b129675a41696a89e5c58de53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that freeing the listener should close the underlying socket. <br /></td></tr>
<tr class="separator:a4b2de09b129675a41696a89e5c58de53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1903214eb069f47ae9119793307b89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a5b1903214eb069f47ae9119793307b89">LEV_OPT_DEFERRED_ACCEPT</a>&#160;&#160;&#160;(1u&lt;&lt;6)</td></tr>
<tr class="memdesc:a5b1903214eb069f47ae9119793307b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that the listener should defer accept() until data is available, if possible.  <a href="listener_8h.html#a5b1903214eb069f47ae9119793307b89">More...</a><br /></td></tr>
<tr class="separator:a5b1903214eb069f47ae9119793307b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96f043f9d9b2f028536fe832061daf6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#ad96f043f9d9b2f028536fe832061daf6">LEV_OPT_DISABLED</a>&#160;&#160;&#160;(1u&lt;&lt;5)</td></tr>
<tr class="memdesc:ad96f043f9d9b2f028536fe832061daf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that the listener should be created in disabled state.  <a href="listener_8h.html#ad96f043f9d9b2f028536fe832061daf6">More...</a><br /></td></tr>
<tr class="separator:ad96f043f9d9b2f028536fe832061daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19549ba5b3746557d5fd8be8a9c5eb3"><td class="memItemLeft" align="right" valign="top"><a id="ac19549ba5b3746557d5fd8be8a9c5eb3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#ac19549ba5b3746557d5fd8be8a9c5eb3">LEV_OPT_LEAVE_SOCKETS_BLOCKING</a>&#160;&#160;&#160;(1u&lt;&lt;0)</td></tr>
<tr class="memdesc:ac19549ba5b3746557d5fd8be8a9c5eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that we should not make incoming sockets nonblocking before passing them to the callback. <br /></td></tr>
<tr class="separator:ac19549ba5b3746557d5fd8be8a9c5eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15337d63b237ec11b0781656aad90662"><td class="memItemLeft" align="right" valign="top"><a id="a15337d63b237ec11b0781656aad90662"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a15337d63b237ec11b0781656aad90662">LEV_OPT_REUSEABLE</a>&#160;&#160;&#160;(1u&lt;&lt;3)</td></tr>
<tr class="memdesc:a15337d63b237ec11b0781656aad90662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that we should disable the timeout (if any) between when this socket is closed and when we can listen again on the same port. <br /></td></tr>
<tr class="separator:a15337d63b237ec11b0781656aad90662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af417f499a89518d16eb3be4098e504c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#af417f499a89518d16eb3be4098e504c7">LEV_OPT_REUSEABLE_PORT</a>&#160;&#160;&#160;(1u&lt;&lt;7)</td></tr>
<tr class="memdesc:af417f499a89518d16eb3be4098e504c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that we ask to allow multiple servers (processes or threads) to bind to the same port if they each set the option for incoming connections/datagrams to be distributed evenly across all of the threads (or processes).  <a href="listener_8h.html#af417f499a89518d16eb3be4098e504c7">More...</a><br /></td></tr>
<tr class="separator:af417f499a89518d16eb3be4098e504c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcc41438093090d28a7c98b899db9ba"><td class="memItemLeft" align="right" valign="top"><a id="a7bcc41438093090d28a7c98b899db9ba"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a7bcc41438093090d28a7c98b899db9ba">LEV_OPT_THREADSAFE</a>&#160;&#160;&#160;(1u&lt;&lt;4)</td></tr>
<tr class="memdesc:a7bcc41438093090d28a7c98b899db9ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag: Indicates that the listener should be locked so it's safe to use from multiple threadcs at once. <br /></td></tr>
<tr class="separator:a7bcc41438093090d28a7c98b899db9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a658a270f1fdad81625bf7c82a08638ca"><td class="memItemLeft" align="right" valign="top"><a id="a658a270f1fdad81625bf7c82a08638ca"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>evconnlistener_cb</b>) (struct evconnlistener *, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>, struct sockaddr *, int socklen, void *)</td></tr>
<tr class="separator:a658a270f1fdad81625bf7c82a08638ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d682ff37636dc08b045aaeff6b538"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a925d682ff37636dc08b045aaeff6b538">evconnlistener_errorcb</a>) (struct evconnlistener *, void *)</td></tr>
<tr class="memdesc:a925d682ff37636dc08b045aaeff6b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callback that we invoke when a listener encounters a non-retriable error.  <a href="listener_8h.html#a925d682ff37636dc08b045aaeff6b538">More...</a><br /></td></tr>
<tr class="separator:a925d682ff37636dc08b045aaeff6b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1f772caf7e2f01276ec33641eb32418c"><td class="memItemLeft" align="right" valign="top"><a id="a1f772caf7e2f01276ec33641eb32418c"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a1f772caf7e2f01276ec33641eb32418c">evconnlistener_disable</a> (struct evconnlistener *lev)</td></tr>
<tr class="memdesc:a1f772caf7e2f01276ec33641eb32418c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop listening for connections on an evconnlistener. <br /></td></tr>
<tr class="separator:a1f772caf7e2f01276ec33641eb32418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890717d86a18e2bd82655fd342b1973f"><td class="memItemLeft" align="right" valign="top"><a id="a890717d86a18e2bd82655fd342b1973f"></a>
EVENT2_EXPORT_SYMBOL int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a890717d86a18e2bd82655fd342b1973f">evconnlistener_enable</a> (struct evconnlistener *lev)</td></tr>
<tr class="memdesc:a890717d86a18e2bd82655fd342b1973f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-enable an evconnlistener that has been disabled. <br /></td></tr>
<tr class="separator:a890717d86a18e2bd82655fd342b1973f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7f3d276f08669c2a9b1817941aa68f"><td class="memItemLeft" align="right" valign="top"><a id="a0f7f3d276f08669c2a9b1817941aa68f"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a0f7f3d276f08669c2a9b1817941aa68f">evconnlistener_free</a> (struct evconnlistener *lev)</td></tr>
<tr class="memdesc:a0f7f3d276f08669c2a9b1817941aa68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable and deallocate an evconnlistener. <br /></td></tr>
<tr class="separator:a0f7f3d276f08669c2a9b1817941aa68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3492fa1741d2b50e151505c0582334d"><td class="memItemLeft" align="right" valign="top"><a id="ab3492fa1741d2b50e151505c0582334d"></a>
EVENT2_EXPORT_SYMBOL struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#ab3492fa1741d2b50e151505c0582334d">evconnlistener_get_base</a> (struct evconnlistener *lev)</td></tr>
<tr class="memdesc:ab3492fa1741d2b50e151505c0582334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an evconnlistener's associated <a class="el" href="structevent__base.html" title="Structure to hold information and state for a Libevent dispatch loop.">event_base</a>. <br /></td></tr>
<tr class="separator:ab3492fa1741d2b50e151505c0582334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e8de702931f3960edd84617e6c2fb6"><td class="memItemLeft" align="right" valign="top"><a id="a56e8de702931f3960edd84617e6c2fb6"></a>
EVENT2_EXPORT_SYMBOL <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a56e8de702931f3960edd84617e6c2fb6">evconnlistener_get_fd</a> (struct evconnlistener *lev)</td></tr>
<tr class="memdesc:a56e8de702931f3960edd84617e6c2fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the socket that an evconnlistner is listening on. <br /></td></tr>
<tr class="separator:a56e8de702931f3960edd84617e6c2fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ae1878cf56d58579b025dd1620c91"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evconnlistener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#aa07ae1878cf56d58579b025dd1620c91">evconnlistener_new</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, <a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a> fd)</td></tr>
<tr class="memdesc:aa07ae1878cf56d58579b025dd1620c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new evconnlistener object to listen for incoming TCP connections on a given file descriptor.  <a href="listener_8h.html#aa07ae1878cf56d58579b025dd1620c91">More...</a><br /></td></tr>
<tr class="separator:aa07ae1878cf56d58579b025dd1620c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29076ec56e051fb75aa48f30cf9111ee"><td class="memItemLeft" align="right" valign="top">EVENT2_EXPORT_SYMBOL struct evconnlistener *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a29076ec56e051fb75aa48f30cf9111ee">evconnlistener_new_bind</a> (struct <a class="el" href="structevent__base.html">event_base</a> *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, const struct sockaddr *sa, int socklen)</td></tr>
<tr class="memdesc:a29076ec56e051fb75aa48f30cf9111ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a new evconnlistener object to listen for incoming TCP connections on a given address.  <a href="listener_8h.html#a29076ec56e051fb75aa48f30cf9111ee">More...</a><br /></td></tr>
<tr class="separator:a29076ec56e051fb75aa48f30cf9111ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf8c1793319829ff9c6d8ce4fea6b342"><td class="memItemLeft" align="right" valign="top"><a id="abf8c1793319829ff9c6d8ce4fea6b342"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#abf8c1793319829ff9c6d8ce4fea6b342">evconnlistener_set_cb</a> (struct evconnlistener *lev, evconnlistener_cb cb, void *arg)</td></tr>
<tr class="memdesc:abf8c1793319829ff9c6d8ce4fea6b342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the callback on the listener to cb and its user_data to arg. <br /></td></tr>
<tr class="separator:abf8c1793319829ff9c6d8ce4fea6b342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328c8f6b2c2b3c87507ca6a4d5790da1"><td class="memItemLeft" align="right" valign="top"><a id="a328c8f6b2c2b3c87507ca6a4d5790da1"></a>
EVENT2_EXPORT_SYMBOL void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="listener_8h.html#a328c8f6b2c2b3c87507ca6a4d5790da1">evconnlistener_set_error_cb</a> (struct evconnlistener *lev, <a class="el" href="listener_8h.html#a925d682ff37636dc08b045aaeff6b538">evconnlistener_errorcb</a> errorcb)</td></tr>
<tr class="memdesc:a328c8f6b2c2b3c87507ca6a4d5790da1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an evconnlistener's error callback. <br /></td></tr>
<tr class="separator:a328c8f6b2c2b3c87507ca6a4d5790da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A callback that we invoke when a listener has a new connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The evconnlistener </td></tr>
    <tr><td class="paramname">fd</td><td>The new file descriptor </td></tr>
    <tr><td class="paramname">addr</td><td>The source address of the connection </td></tr>
    <tr><td class="paramname">socklen</td><td>The length of addr </td></tr>
    <tr><td class="paramname">user_arg</td><td>the pointer passed to <a class="el" href="listener_8h.html#aa07ae1878cf56d58579b025dd1620c91" title="Allocate a new evconnlistener object to listen for incoming TCP connections on a given file descripto...">evconnlistener_new()</a> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afc396525343a6848149d6c0f7cd11ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc396525343a6848149d6c0f7cd11ed5">&#9670;&nbsp;</a></span>LEV_OPT_BIND_IPV4_AND_IPV6</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEV_OPT_BIND_IPV4_AND_IPV6&#160;&#160;&#160;(1u&lt;&lt;9)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag: Indicates that the listener wants to work only in both IPv4 and IPv6 socket. </p>
<p>This flag exists as complement to LEV_OPT_BIND_IPV6ONLY to account for the different default behaviour on Windows so that the code can explicitly request the socket to support both modes without having to rely on the default option. </p>

</div>
</div>
<a id="a3a54f81b44cec176dffe72a1aa22d8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a54f81b44cec176dffe72a1aa22d8e6">&#9670;&nbsp;</a></span>LEV_OPT_BIND_IPV6ONLY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEV_OPT_BIND_IPV6ONLY&#160;&#160;&#160;(1u&lt;&lt;8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag: Indicates that the listener wants to work only in IPv6 socket. </p>
<p>According to RFC3493 and most Linux distributions, default value is to work in IPv4-mapped mode. If there is a requirement to bind same port on same ip addresses but different handlers for both IPv4 and IPv6, it is required to set IPV6_V6ONLY socket option to be sure that the code works as expected without affected by bindv6only sysctl setting in system.</p>
<p>This socket option on Windows is instead enabled by default. </p>

</div>
</div>
<a id="a5b1903214eb069f47ae9119793307b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1903214eb069f47ae9119793307b89">&#9670;&nbsp;</a></span>LEV_OPT_DEFERRED_ACCEPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEV_OPT_DEFERRED_ACCEPT&#160;&#160;&#160;(1u&lt;&lt;6)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag: Indicates that the listener should defer accept() until data is available, if possible. </p>
<p>Ignored on platforms that do not support this.</p>
<p>This option can help performance for protocols where the client transmits immediately after connecting. Do not use this option if your protocol <em>doesn't</em> start out with the client transmitting data, since in that case this option will sometimes cause the kernel to never tell you about the connection.</p>
<p>This option is only supported by <a class="el" href="listener_8h.html#a29076ec56e051fb75aa48f30cf9111ee" title="Allocate a new evconnlistener object to listen for incoming TCP connections on a given address.">evconnlistener_new_bind()</a>: it can't work with evconnlistener_new_fd(), since the listener needs to be told to use the option before it is actually bound. </p>

</div>
</div>
<a id="ad96f043f9d9b2f028536fe832061daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96f043f9d9b2f028536fe832061daf6">&#9670;&nbsp;</a></span>LEV_OPT_DISABLED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEV_OPT_DISABLED&#160;&#160;&#160;(1u&lt;&lt;5)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag: Indicates that the listener should be created in disabled state. </p>
<p>Use <a class="el" href="listener_8h.html#a890717d86a18e2bd82655fd342b1973f" title="Re-enable an evconnlistener that has been disabled.">evconnlistener_enable()</a> to enable it later. </p>

</div>
</div>
<a id="af417f499a89518d16eb3be4098e504c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af417f499a89518d16eb3be4098e504c7">&#9670;&nbsp;</a></span>LEV_OPT_REUSEABLE_PORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LEV_OPT_REUSEABLE_PORT&#160;&#160;&#160;(1u&lt;&lt;7)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag: Indicates that we ask to allow multiple servers (processes or threads) to bind to the same port if they each set the option for incoming connections/datagrams to be distributed evenly across all of the threads (or processes). </p>
<p>SO_REUSEPORT is what most people would expect SO_REUSEADDR to be, however SO_REUSEPORT does not imply SO_REUSEADDR.</p>
<p>This feature is available only on Linux 3.9+, DragonFlyBSD 3.6+, FreeBSD 12.0+, Solaris 11.4, AIX 7.2.5 for now. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a925d682ff37636dc08b045aaeff6b538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d682ff37636dc08b045aaeff6b538">&#9670;&nbsp;</a></span>evconnlistener_errorcb</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* evconnlistener_errorcb) (struct evconnlistener *, void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A callback that we invoke when a listener encounters a non-retriable error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The evconnlistener </td></tr>
    <tr><td class="paramname">user_arg</td><td>the pointer passed to <a class="el" href="listener_8h.html#aa07ae1878cf56d58579b025dd1620c91" title="Allocate a new evconnlistener object to listen for incoming TCP connections on a given file descripto...">evconnlistener_new()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa07ae1878cf56d58579b025dd1620c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa07ae1878cf56d58579b025dd1620c91">&#9670;&nbsp;</a></span>evconnlistener_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evconnlistener* evconnlistener_new </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evconnlistener_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="util_8h.html#a7ef0023565082a65020f6e56be59fd0b">evutil_socket_t</a>&#160;</td>
          <td class="paramname"><em>fd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new evconnlistener object to listen for incoming TCP connections on a given file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The event base to associate the listener with. </td></tr>
    <tr><td class="paramname">cb</td><td>A callback to be invoked when a new connection arrives. If the callback is NULL, the listener will be treated as disabled until the callback is set. </td></tr>
    <tr><td class="paramname">ptr</td><td>A user-supplied pointer to give to the callback. </td></tr>
    <tr><td class="paramname">flags</td><td>Any number of LEV_OPT_* flags </td></tr>
    <tr><td class="paramname">backlog</td><td>Passed to the listen() call to determine the length of the acceptable connection backlog. Set to -1 for a reasonable default. Set to 0 if the socket is already listening. </td></tr>
    <tr><td class="paramname">fd</td><td>The file descriptor to listen on. It must be a nonblocking file descriptor, and it should already be bound to an appropriate port and address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29076ec56e051fb75aa48f30cf9111ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29076ec56e051fb75aa48f30cf9111ee">&#9670;&nbsp;</a></span>evconnlistener_new_bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EVENT2_EXPORT_SYMBOL struct evconnlistener* evconnlistener_new_bind </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structevent__base.html">event_base</a> *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">evconnlistener_cb&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socklen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate a new evconnlistener object to listen for incoming TCP connections on a given address. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The event base to associate the listener with. </td></tr>
    <tr><td class="paramname">cb</td><td>A callback to be invoked when a new connection arrives. If the callback is NULL, the listener will be treated as disabled until the callback is set. </td></tr>
    <tr><td class="paramname">ptr</td><td>A user-supplied pointer to give to the callback. </td></tr>
    <tr><td class="paramname">flags</td><td>Any number of LEV_OPT_* flags </td></tr>
    <tr><td class="paramname">backlog</td><td>Passed to the listen() call to determine the length of the acceptable connection backlog. Set to -1 for a reasonable default. </td></tr>
    <tr><td class="paramname">sa</td><td>The address to listen for connections on. </td></tr>
    <tr><td class="paramname">socklen</td><td>The length of the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
